 # nebulaTrace
 Appplication serv ant a enregistrer tous ce qui ce passe sur le LAN et a le monitorer.
##  
NebulaTrace (C++) 
   â”œâ”€â”€ Enregistre en DB (live pour l'API)
   â””â”€â”€ Archive en PCAP (pour Wireshark ou replays)
g++ src/main.cpp -o build/NebulaTrace



### tableau dÃ©sitionnelle
| **MÃ©thode** | **Points positifs** | **Points nÃ©gatifs** | **Remarques spÃ©cifiques pour ton projet** |
|:------------|:--------------------|:--------------------|:-------------------------------------------|
| **Base de donnÃ©es** (MySQL, SQLite, etc.) | - AccÃ¨s ultra rapide pour l'API<br>- RequÃªtes filtrÃ©es (IP, protocole, temps)<br>- PrÃªt pour *temps rÃ©el* et historique | - ComplexitÃ© Ã  gÃ©rer (indexation, nettoyage, volumÃ©trie Ã©norme)<br>- Peut ralentir la capture si mal optimisÃ©<br>- Besoin de faire attention aux Ã©critures concurrentes | ğŸ”¥ IdÃ©al pour interaction Web (API REST) mais Ã  condition de bufferiser ou batcher les insertions pour Ã©viter dâ€™Ã©trangler le Raspberry. |
| **Fichiers JSON** (un gros fichier ou par paquet) | - Facile Ã  lire/consommer<br>- PrÃªt pour API qui stream du JSON<br>- Simple Ã  produire en C++ | - Risque dâ€™avoir de trÃ¨s gros fichiers trÃ¨s vite<br>- Parsing coÃ»teux en RAM<br>- Pas "queryable" facilement sans tout lire | âš¡ Bonne solution temporaire pour dÃ©veloppement rapide, mais limitÃ© en scalabilitÃ© si tu veux capturer plusieurs heures/jours de trafic. |
| **Fichier PCAP** (format brut rÃ©seau) | - Standard rÃ©seau universel (Wireshark, tcpdump)<br>- Ultra efficace en Ã©criture (format brut)<br>- Compact | - Difficilement lisible directement par une API<br>- NÃ©cessite une Ã©tape de parsing pour extraire les infos utiles<br>- Pas idÃ©al pour temps rÃ©el sans transformation | ğŸ” TrÃ¨s bien pour archivage ou analyse "offline", mais pas directement exploitable pour ton objectif Web/API temps rÃ©el. |

| Base de donnÃ©es | Avantages | InconvÃ©nients | Verdict |
|:---------------|:----------|:--------------|:--------|
| **SQLite** | - Ultra lÃ©gÃ¨re, fichier unique<br>- Aucune installation serveur<br>- Parfait pour petit Ã  moyen trafic | - Pas fait pour du trÃ¨s gros volume<br>- Pas de vraie concurrence multi-accÃ¨s lourd | âœ… **Parfait** pour dÃ©buter, simple, rapide |
| **MariaDB/MySQL** | - Plus robuste pour gros trafic<br>- RequÃªtes avancÃ©es possibles<br>- Bon support multi-connexion | - Plus lourd<br>- NÃ©cessite un serveur qui tourne tout le temps | ğŸ”¥ **IdÃ©al si tu vises un vrai environnement "prod"**, notamment avec beaucoup de requÃªtes/API |
| **PostgreSQL** | - TrÃ¨s puissant<br>- GÃ¨re super bien les gros datasets<br>- Transactions parfaites | - TrÃ¨s lourd pour un Raspberry Pi (par dÃ©faut)<br>- Besoin de config fine pour performances correctes | ğŸ›‘ Trop pour ton besoin actuel sur Pi sauf si tu optimises Ã  fond |


### Fonctionnement discover Web
[Envoyer ARP Broadcast] -- toutes les 30 seconde (variable changeable dans le Main :D)
      â†“
[Lire /proc/net/arp]
      â†“
[Enregistrer IP/MAC dans la BDD]
      â†“
[Toutes 10 min : scanner IP en ping] -- controle les IP silencieux et complette la table.
      â†“
[ComplÃ©ter / mettre Ã  jour la BDD]


### liste de tache
1. crÃ©er un sÃ©curity calss qui auras comme fonction de controler que l'app a les droit pour tout faire (paramaitre les droit pour ne pas avoir besoin de le lancer en root)